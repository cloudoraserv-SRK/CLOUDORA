{
  "module": "tech_docs",
  "version": "2.0",
  "documents": [

    {
      "id": "tech_overview",
      "title": "Technical Documentation Overview",
      "category": "tech",
      "content": "Cloudora Genie's architecture includes frontend UI, backend chat engine, STT/TTS systems, Supabase database, vector search pipeline, ingestion scripts, and deployment infrastructure. The system is modular, scalable, multilingual, and designed for fast updates with minimal interruption.",
      "metadata": {}
    },

    {
      "id": "tech_frontend_structure",
      "title": "Frontend Architecture Overview",
      "category": "tech",
      "content": "Frontend files include index.html, style.css, script.js, and folders client/*, employee/*, assets/* for graphics and media. Genie uses WebSpeech API for browser-based STT and TTS with provisions to switch to Google STT/TTS later. Session handling uses a lightweight sessionId cookie for dev and persistent Supabase-backed memory for production.",
      "metadata": {}
    },

    {
      "id": "tech_backend_structure",
      "title": "Backend Architecture Overview",
      "category": "tech",
      "content": "Backend entry file: backend/index.js. Core routes include /api/genie for replies, /api/genie/role for role switching, /api/enquiries/log for logging leads, /api/onboarding/log for onboarding steps, and /api/upload for asset handling. The backend composes context using vector search, flow_manager logic, and Genie behavioral rules.",
      "metadata": {}
    },

    {
      "id": "tech_supabase_overview",
      "title": "Supabase Structure Overview",
      "category": "tech",
      "content": "Supabase buckets: catalogue_images, partner_uploads, resumes, creative_assets. RLS rules: public Genie can read product metadata; employees can read extended fields; admin can edit all. Upload endpoint requires authentication. Metadata fields include product_id, uploader_role, and asset notes.",
      "metadata": {}
    },

    {
      "id": "tech_supabase_upload_example",
      "title": "Supabase Upload Endpoint Example",
      "category": "tech",
      "content": "Example endpoint: POST /api/upload with fields file, product_id, uploader_role, meta. Returns JSON: {ok:true, url:'...'} after uploading to the correct bucket. Uploads enforce size limits (50MB) and allowed MIME types (jpeg, png, mp4, pdf).",
      "metadata": {}
    },

    {
      "id": "tech_repo_structure",
      "title": "Repository and File Structure",
      "category": "tech",
      "content": "Recommended layout: root contains server/, genie/, knowledge-base/, scripts/, deploy/, assets/, i18n/. Genie UI files in genie/ui/. Core logic in genie/genie-core.js. KB modules stored as kb_*.json in genie/kb/. Ingestion scripts in scripts/ingest_master.js and scripts/ingest_retry.js. Manifest file defines imports/exports and ensures consistency.",
      "metadata": {}
    },

    {
      "id": "tech_kb_ingestion_note",
      "title": "KB Ingestion Workflow Overview",
      "category": "tech",
      "content": "Ingestion pipeline: load kb_master.json, read each module file, flatten entries, chunk content, generate embeddings, upsert into Supabase vector table kb_vectors. Requires match_kb RPC to support search. Uses Gemini embeddings by default.",
      "metadata": {}
    },

    {
      "id": "tech_embedding_pipeline",
      "title": "Embedding Pipeline & Chunking",
      "category": "tech",
      "content": "Process: load modular KB files, chunk content into 300-500 token blocks, maintain metadata such as module, source_file, id, category, and language. Use Gemini embedding API. Upsert embeddings into Supabase with vector dimension validation. Avoid duplicates by hashing chunk content.",
      "metadata": {}
    },

    {
      "id": "tech_ingest_orchestrator",
      "title": "Ingest Orchestrator Script",
      "category": "tech",
      "content": "scripts/ingest_master.js loops over modules, chunks content, generates embeddings with concurrency limits, retries on failure, logs errors, and maintains idempotency. It also updates a supabase table for ingest history. ingest_retry.js processes failed jobs.",
      "metadata": {}
    },

    {
      "id": "tech_retry_and_backoff",
      "title": "Retry, Backoff and Error Handling",
      "category": "tech",
      "content": "Embedding failures use exponential backoff with jitter and up to 5 retries. Failed chunks saved to a retry queue. Orchestrator supports resume using progress markers. Backend validates embedding dimension before querying match_kb to avoid mismatches.",
      "metadata": {}
    },

    {
      "id": "tech_vector_function",
      "title": "Postgres Vector Function and Search",
      "category": "tech",
      "content": "match_kb RPC takes a vector, match_count, and threshold. It searches kb_vectors using cosine similarity and returns: id, title, content, category, similarity, metadata. Requires correct vector dimension and non-null embeddings. Supports both internal and public KB rows.",
      "metadata": {}
    },

    {
      "id": "tech_api_endpoints",
      "title": "Backend API Endpoints",
      "category": "tech",
      "content": "Core endpoints: POST /genie/chat for message handling; POST /genie/ingest for ingestion trigger; POST /api/tts for TTS streaming; POST /api/stt for optional server-side transcription. All sensitive endpoints must use service keys or auth tokens. Rate limit /genie/chat.",
      "metadata": {}
    },

    {
      "id": "tech_stt_integration",
      "title": "STT Integration and Fallbacks",
      "category": "tech",
      "content": "Primary: Web Speech API for in-browser transcription. Fallback: server-side Google STT. Include silence detection, auto-cancel, multi-language detection, and restart-on-error logic. Genie stores transcript and sends it to backend for context building.",
      "metadata": {}
    },

    {
      "id": "tech_tts_integration",
      "title": "TTS Integration and Caching",
      "category": "tech",
      "content": "Genie uses Gemini TTS for premium voices. Browser SpeechSynthesis works as fallback. Cache frequent replies. Support multilingual voices. Serve audio via streaming for low latency.",
      "metadata": {}
    },

    {
      "id": "tech_security_and_env",
      "title": "Security, ENV and Secrets Management",
      "category": "tech",
      "content": "Secret keys stored in environment variables: SUPABASE_URL, SUPABASE_SERVICE_KEY, GEMINI_API_KEY, GOOGLE_JSON, PROJECT_ID. Never commit .env. Apply RLS policies in Supabase. Restrict service key to ingestion server only. Enable 2FA for admin dashboards.",
      "metadata": {}
    },

    {
      "id": "tech_deployment_guide",
      "title": "Deployment Guide",
      "category": "tech",
      "content": "Backend deployable on Render, Railway, or any Node host. Start: node backend/index.js. Configure CORS for frontend domain. Frontend can be deployed on GitHub Pages or Vercel. Ensure correct environment variables and health endpoints for uptime monitoring.",
      "metadata": {}
    },

    {
      "id": "tech_monitoring_and_logging",
      "title": "Monitoring, Logging and Alerts",
      "category": "tech",
      "content": "Use structured logs. Track API latency, embedding failures, ingestion errors, vector table dimension mismatches, and STT permission issues. Provide admin dashboard for ingest status. Enable alerts for downed services or failed ingestion batches.",
      "metadata": {}
    },

    {
      "id": "tech_manifest_and_versioning",
      "title": "Manifest-Based Development and Versioning",
      "category": "tech",
      "content": "A manifest defines filenames, imports, exports, UI IDs, and flows. Update manifest on every structural change. KB modules follow semantic versioning. kb_master.json must reference correct versioned files to ensure stable ingestion and rollback.",
      "metadata": {}
    },

    {
      "id": "tech_auto_update_strategy",
      "title": "Auto-Update Strategy for KB",
      "category": "tech",
      "content": "The orchestrator monitors KB file timestamps or admin-triggered webhooks. If changes detected, only updated segments are re-ingested. Supabase table logs updates. Genie receives refreshed vector context without redeploying backend.",
      "metadata": {}
    },

    {
      "id": "tech_asset_workflow",
      "title": "Asset Workflow Overview",
      "category": "tech",
      "content": "Admins can upload product catalogue assets via admin panel. Uploaded files go to Supabase bucket and update product metadata. Partners upload to partner_uploads bucket with admin approval flag. Optional serverless thumbnail generator creates optimized previews. Frontend displays assets dynamically.",
      "metadata": {}
    }

  ]
}
